# 🧮 Fibonacci Decomposition

## 📚 Description

\*\*제켄도르프의 정리(Zekendorf's Theorem)\*\*에 따르면, 모든 자연수는 **연속되지 않은 피보나치 수들의 합**으로 **고유하게(unique)** 표현될 수 있다.

### Zekendorf's Theorem

임의의 자연수 $N$에 대해, 아래와 같은 합이 존재한다:

$$
N = F(k_1) + F(k_2) + ... + F(k_m)
$$

여기서 $F(k_i)$는 피보나치 수이고, $k_i$는 서로 다른 자연수이며 **연속된 피보나치 수는 포함되지 않는다.**

이 표현은 항상 존재하며 **유일하다.**

### 예시

자연수 $N = 100$일 때:

* 100 이하의 가장 큰 피보나치 수는 **89**
* 100 - 89 = 11 → 가장 큰 피보나치 수는 **8**
* 11 - 8 = 3 → 가장 큰 피보나치 수는 **3**
* 3 - 3 = 0 → 종료

결과: **100 = 89 + 8 + 3** (모두 피보나치 수이며, 연속된 항 없음)

---

## 📥 Input

* 첫째 줄: 자연수 $N$

> 범위: $1 \leq N \leq 2^{64} - 1$

---

## 📤 Output

* 총 M줄에 걸쳐, 분해된 **피보나치 수들을 오름차순**으로 출력한다.
* 모든 피보나치 수들의 합은 정확히 **N**이어야 하며, **연속된 피보나치 수는 포함되어선 안 됨**

### 예시 입력

```
100
```

### 예시 출력

```
3
8
89
```

---

## ⚙️ 알고리즘 개요 (Greedy)

1. $N$ 이하의 피보나치 수열을 미리 생성
2. $N$에서 시작하여 가장 큰 피보나치 수 $F$를 선택 (단, 연속된 수 제외)
3. $N = N - F$ 수행
4. 위 과정을 $N = 0$ 될 때까지 반복
5. 선택한 피보나치 수들을 **오름차순 정렬** 후 출력

---

## 💡 구현 팁

* 피보나치 수열은 미리 64비트 범위 내에서 생성해 둘 것
* `vector<uint64_t>` 또는 `unsigned long long` 자료형 사용 권장
* 그리디 방식이기 때문에 **항상 유일한 해를 반환**함

---
